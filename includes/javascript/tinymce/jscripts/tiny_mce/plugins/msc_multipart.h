<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Apache Portable Runtime: Memory Pool Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Memory Pool Functions<br/>
<small>
[<a class="el" href="group___a_p_r.html">Apache Portability Runtime library</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pool_cleanup.html">Pool Cleanup Functions</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___pool_debug.html">Pool Debugging functions.</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga89ce1d55c7f0c39ea87c88eabd655394">APR_POOL_DECLARE_ACCESSOR</a>(type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga43a8a52f68f8b7d3b7694c254da4a074">APR_POOL_IMPLEMENT_ACCESSOR</a>(type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gad898431056ee6f544e0632f2cf5706c4">APR_POOL_DEBUG</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gac81cff34d0ff4be52fa924663478eade">APR_POOL__FILE_LINE__</a>&nbsp;&nbsp;&nbsp;__FILE__ &quot;:&quot; APR_STRINGIFY(__LINE__)</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga0a1fe549a7c45b864c003ddf12115365">apr_abortfunc_t</a> )(int retcode)</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gad64a6a29515621bc13f8a8da50366d67">apr_pool_initialize</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga3728aacec227318cef973b8a33f3b430">apr_pool_terminate</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gab274bd29e4e4d4944b4618403148074f">apr_pool_create_ex</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> **newpool, <a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *parent, <a class="el" href="group__apr__pools.html#ga0a1fe549a7c45b864c003ddf12115365">apr_abortfunc_t</a> abort_fn, <a class="el" href="group__apr__allocator.html#ga1ceabfd30fcfc455e47d052d2a24244b">apr_allocator_t</a> *allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga20e514c83555398acddc30c4dfa0c540">apr_pool_create_core_ex</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> **newpool, <a class="el" href="group__apr__pools.html#ga0a1fe549a7c45b864c003ddf12115365">apr_abortfunc_t</a> abort_fn, <a class="el" href="group__apr__allocator.html#ga1ceabfd30fcfc455e47d052d2a24244b">apr_allocator_t</a> *allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gaae7212db77bb57f86419cd594f73a92f">apr_pool_create_unmanaged_ex</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> **newpool, <a class="el" href="group__apr__pools.html#ga0a1fe549a7c45b864c003ddf12115365">apr_abortfunc_t</a> abort_fn, <a class="el" href="group__apr__allocator.html#ga1ceabfd30fcfc455e47d052d2a24244b">apr_allocator_t</a> *allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gacbea97ae5c0c861f6b7c147d46ac1d0c">apr_pool_create_ex_debug</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> **newpool, <a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *parent, <a class="el" href="group__apr__pools.html#ga0a1fe549a7c45b864c003ddf12115365">apr_abortfunc_t</a> abort_fn, <a class="el" href="group__apr__allocator.html#ga1ceabfd30fcfc455e47d052d2a24244b">apr_allocator_t</a> *allocator, const char *file_line)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gaa1c5bfc44188884bb439670f81448c20">apr_pool_create_core_ex_debug</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> **newpool, <a class="el" href="group__apr__pools.html#ga0a1fe549a7c45b864c003ddf12115365">apr_abortfunc_t</a> abort_fn, <a class="el" href="group__apr__allocator.html#ga1ceabfd30fcfc455e47d052d2a24244b">apr_allocator_t</a> *allocator, const char *file_line)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gae220e572b14355f1aa7b21c8fb022524">apr_pool_create_unmanaged_ex_debug</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> **newpool, <a class="el" href="group__apr__pools.html#ga0a1fe549a7c45b864c003ddf12115365">apr_abortfunc_t</a> abort_fn, <a class="el" href="group__apr__allocator.html#ga1ceabfd30fcfc455e47d052d2a24244b">apr_allocator_t</a> *allocator, const char *file_line)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga918adf3026c894efeae254a0446aed3b">apr_pool_create</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> **newpool, <a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *parent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gad3675378924bc9d98e46258c049f1761">apr_pool_create_core</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> **newpool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga72f86d699b4b2ec2aeb82c334ca3446b"></a><!-- doxytag: member="apr_pools::apr_pool_create_unmanaged" ref="ga72f86d699b4b2ec2aeb82c334ca3446b" args="(apr_pool_t **newpool)" -->
<a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>apr_pool_create_unmanaged</b> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> **newpool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__allocator.html#ga1ceabfd30fcfc455e47d052d2a24244b">apr_allocator_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gaf446fcf5da1fcd62d3f802a4c0c10f97">apr_pool_allocator_get</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *pool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gafa8a998cd660e82b62aecec09e239d0d">apr_pool_clear</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga9521870e42ec4395a0bf8388706a57b9">apr_pool_clear_debug</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, const char *file_line)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga54759954d2cba7cb649ab5680a33f9e3">apr_pool_destroy</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga7efe64dfcce883d7fad9df813d9259fc">apr_pool_destroy_debug</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, const char *file_line)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga85f1e193c31d109affda72f9a92c6915">apr_palloc</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, apr_size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga0ac211ac89be868b107776b4183a8174">apr_palloc_debug</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, apr_size_t size, const char *file_line)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gaf61c098ad258069d64cdf8c0a9369f9e">apr_pcalloc</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, apr_size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga7b43035318ffdc57a6eddab07dc57cb2">apr_pcalloc_debug</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, apr_size_t size, const char *file_line)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gaa658b1f10dd13967eaa7c4156d4c2174">apr_pool_abort_set</a> (<a class="el" href="group__apr__pools.html#ga0a1fe549a7c45b864c003ddf12115365">apr_abortfunc_t</a> abortfunc, <a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *pool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__pools.html#ga0a1fe549a7c45b864c003ddf12115365">apr_abortfunc_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gaf7610c30ef5f84a8742c0b3e63fdd7b0">apr_pool_abort_get</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *pool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga94db31f40609b15b592ff47f989ca9ec">apr_pool_parent_get</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *pool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga05d299f778659d1e0806140d8a7fea79">apr_pool_is_ancestor</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *a, <a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gaeaa872f7999740a60803e95429890518">apr_pool_tag</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *pool, const char *tag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga78d1aa2d9fa842d83eaffccb0f0c0c5c">apr_pool_userdata_set</a> (const void *data, const char *key, <a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>(*cleanup)(void *), <a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *pool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga435644c493dc5b10d80c4b99b8cd4589">apr_pool_userdata_setn</a> (const void *data, const char *key, <a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>(*cleanup)(void *), <a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *pool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gaf930f1fad2cf92a2432c0814c8a0b86f">apr_pool_userdata_get</a> (void **data, const char *key, <a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *pool)</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gac81cff34d0ff4be52fa924663478eade"></a><!-- doxytag: member="apr_pools.h::APR_POOL__FILE_LINE__" ref="gac81cff34d0ff4be52fa924663478eade" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_POOL__FILE_LINE__&nbsp;&nbsp;&nbsp;__FILE__ &quot;:&quot; APR_STRINGIFY(__LINE__)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>the place in the code where the particular function was called </p>

</div>
</div>
<a class="anchor" id="gad898431056ee6f544e0632f2cf5706c4"></a><!-- doxytag: member="apr_pools.h::APR_POOL_DEBUG" ref="gad898431056ee6f544e0632f2cf5706c4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_POOL_DEBUG&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pool debug levels</p>
<pre>
 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
 ---------------------------------
 |   |   |   |   |   |   |   | x |  General debug code enabled (useful in
                                    combination with --with-efence).</pre><pre> |   |   |   |   |   |   | x |   |  Verbose output on stderr (report
                                    CREATE, CLEAR, DESTROY).</pre><pre> |   |   |   | x |   |   |   |   |  Verbose output on stderr (report
                                    PALLOC, PCALLOC).</pre><pre> |   |   |   |   |   | x |   |   |  Lifetime checking. On each use of a
                                    pool, check its lifetime.  If the pool
                                    is out of scope, abort().
                                    In combination with the verbose flag
                                    above, it will output LIFE in such an
                                    event prior to aborting.</pre><pre> |   |   |   |   | x |   |   |   |  Pool owner checking.  On each use of a
                                    pool, check if the current thread is the
                                    pools owner.  If not, abort().  In
                                    combination with the verbose flag above,
                                    it will output OWNER in such an event
                                    prior to aborting.  Use the debug
                                    function apr_pool_owner_set() to switch
                                    a pools ownership.</pre><pre> When no debug level was specified, assume general debug mode.
 If level 0 was specified, debugging is switched off
 </pre> 
</div>
</div>
<a class="anchor" id="ga89ce1d55c7f0c39ea87c88eabd655394"></a><!-- doxytag: member="apr_pools.h::APR_POOL_DECLARE_ACCESSOR" ref="ga89ce1d55c7f0c39ea87c88eabd655394" args="(type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_POOL_DECLARE_ACCESSOR</td>
          <td>(</td>
          <td class="paramtype">type&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="group__apr__platform.html#gad7b91b811a172bfa802603c2fb688f98">APR_DECLARE</a>(<a class="code" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *) apr_<span class="preprocessor">##type##_pool_get \</span>
<span class="preprocessor">        (const apr_##type##_t *the##type)</span>
</pre></div><p>Declaration helper macro to construct apr_foo_pool_get()s.</p>
<p>This standardized macro is used by opaque (APR) data types to return the apr_pool_t that is associated with the data type.</p>
<p><a class="el" href="group__apr__pools.html#ga89ce1d55c7f0c39ea87c88eabd655394">APR_POOL_DECLARE_ACCESSOR()</a> is used in a header file to declare the accessor function. A typical usage and result would be: </p>
<pre>
    <a class="el" href="group__apr__pools.html#ga89ce1d55c7f0c39ea87c88eabd655394">APR_POOL_DECLARE_ACCESSOR(file)</a>;
 becomes:
    <a class="el" href="group__apr__platform.html#gad7b91b811a172bfa802603c2fb688f98">APR_DECLARE(apr_pool_t *)</a> apr_file_pool_get(apr_file_t *ob);
 </pre> <dl class="remark"><dt><b>Remarks:</b></dt><dd>Doxygen unwraps this macro (via doxygen.conf) to provide actual help for each specific occurance of apr_foo_pool_get. </dd>
<dd>
the linkage is specified for APR. It would be possible to expand the macros to support other linkages. </dd></dl>

</div>
</div>
<a class="anchor" id="ga43a8a52f68f8b7d3b7694c254da4a074"></a><!-- doxytag: member="apr_pools.h::APR_POOL_IMPLEMENT_ACCESSOR" ref="ga43a8a52f68f8b7d3b7694c254da4a074" args="(type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_POOL_IMPLEMENT_ACCESSOR</td>
          <td>(</td>
          <td class="paramtype">type&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="group__apr__platform.html#gad7b91b811a172bfa802603c2fb688f98">APR_DECLARE</a>(<a class="code" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *) apr_<span class="preprocessor">##type##_pool_get \</span>
<span class="preprocessor">            (const apr_##type##_t *the##type) \</span>
<span class="preprocessor">        { return the##type-&gt;pool; }</span>
</pre></div><p>Implementation helper macro to provide apr_foo_pool_get()s.</p>
<p>In the implementation, the <a class="el" href="group__apr__pools.html#ga43a8a52f68f8b7d3b7694c254da4a074">APR_POOL_IMPLEMENT_ACCESSOR()</a> is used to actually define the function. It assumes the field is named "pool". </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga0a1fe549a7c45b864c003ddf12115365"></a><!-- doxytag: member="apr_pools.h::apr_abortfunc_t" ref="ga0a1fe549a7c45b864c003ddf12115365" args=")(int retcode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="group__apr__pools.html#ga0a1fe549a7c45b864c003ddf12115365">apr_abortfunc_t</a>)(int retcode)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A function that is called when allocation fails. </p>

</div>
</div>
<a class="anchor" id="gaf137f28edcf9a086cd6bc36c20d7cdfb"></a><!-- doxytag: member="apr_pools.h::apr_pool_t" ref="gaf137f28edcf9a086cd6bc36c20d7cdfb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> <a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The fundamental pool type </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga85f1e193c31d109affda72f9a92c6915"></a><!-- doxytag: member="apr_pools.h::apr_palloc" ref="ga85f1e193c31d109affda72f9a92c6915" args="(apr_pool_t *p, apr_size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* apr_palloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a block of memory from a pool </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The pool to allocate from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The amount of memory to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The allocated memory </dd></dl>

</div>
</div>
<a class="anchor" id="ga0ac211ac89be868b107776b4183a8174"></a><!-- doxytag: member="apr_pools.h::apr_palloc_debug" ref="ga0ac211ac89be868b107776b4183a8174" args="(apr_pool_t *p, apr_size_t size, const char *file_line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* apr_palloc_debug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file_line</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Debug version of apr_palloc </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>See: apr_palloc </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>See: apr_palloc </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>file_line</em>&nbsp;</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>See: apr_palloc </dd></dl>

</div>
</div>
<a class="anchor" id="gaf61c098ad258069d64cdf8c0a9369f9e"></a><!-- doxytag: member="apr_pools.h::apr_pcalloc" ref="gaf61c098ad258069d64cdf8c0a9369f9e" args="(apr_pool_t *p, apr_size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* apr_pcalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a block of memory from a pool and set all of the memory to 0 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The pool to allocate from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The amount of memory to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The allocated memory </dd></dl>

</div>
</div>
<a class="anchor" id="ga7b43035318ffdc57a6eddab07dc57cb2"></a><!-- doxytag: member="apr_pools.h::apr_pcalloc_debug" ref="ga7b43035318ffdc57a6eddab07dc57cb2" args="(apr_pool_t *p, apr_size_t size, const char *file_line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* apr_pcalloc_debug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file_line</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Debug version of apr_pcalloc </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>See: apr_pcalloc </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>See: apr_pcalloc </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>file_line</em>&nbsp;</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>See: apr_pcalloc </dd></dl>

</div>
</div>
<a class="anchor" id="gaf7610c30ef5f84a8742c0b3e63fdd7b0"></a><!-- doxytag: member="apr_pools.h::apr_pool_abort_get" ref="gaf7610c30ef5f84a8742c0b3e63fdd7b0" args="(apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__pools.html#ga0a1fe549a7c45b864c003ddf12115365">apr_abortfunc_t</a> apr_pool_abort_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the abort function associated with the specified pool. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>The pool for retrieving the abort function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The abort function for the given pool. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa658b1f10dd13967eaa7c4156d4c2174"></a><!-- doxytag: member="apr_pools.h::apr_pool_abort_set" ref="gaa658b1f10dd13967eaa7c4156d4c2174" args="(apr_abortfunc_t abortfunc, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_pool_abort_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#ga0a1fe549a7c45b864c003ddf12115365">apr_abortfunc_t</a>&nbsp;</td>
          <td class="paramname"> <em>abortfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the function to be called when an allocation failure occurs. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>If the program wants APR to exit on a memory allocation error, then this function can be called to set the callback to use (for performing cleanup and then exiting). If this function is not called, then APR will return an error and expect the calling program to deal with the error accordingly. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf446fcf5da1fcd62d3f802a4c0c10f97"></a><!-- doxytag: member="apr_pools.h::apr_pool_allocator_get" ref="gaf446fcf5da1fcd62d3f802a4c0c10f97" args="(apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__allocator.html#ga1ceabfd30fcfc455e47d052d2a24244b">apr_allocator_t</a>* apr_pool_allocator_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the pools allocator </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>The pool to get the allocator from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafa8a998cd660e82b62aecec09e239d0d"></a><!-- doxytag: member="apr_pools.h::apr_pool_clear" ref="gafa8a998cd660e82b62aecec09e239d0d" args="(apr_pool_t *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_pool_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clear all memory in the pool and run all the cleanups. This also destroys all subpools. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The pool to clear </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This does not actually free the memory, it just allows the pool to re-use this memory for the next allocation. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__apr__pools.html#ga54759954d2cba7cb649ab5680a33f9e3">apr_pool_destroy()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9521870e42ec4395a0bf8388706a57b9"></a><!-- doxytag: member="apr_pools.h::apr_pool_clear_debug" ref="ga9521870e42ec4395a0bf8388706a57b9" args="(apr_pool_t *p, const char *file_line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_pool_clear_debug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file_line</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Debug version of apr_pool_clear. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>See: apr_pool_clear. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>file_line</em>&nbsp;</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Only available when APR_POOL_DEBUG is defined. Call this directly if you have you apr_pool_clear calls in a wrapper function and wish to override the file_line argument to reflect the caller of your wrapper function. If you do not have apr_pool_clear in a wrapper, trust the macro and don't call apr_pool_destroy_clear directly. </dd></dl>

</div>
</div>
<a class="anchor" id="ga918adf3026c894efeae254a0446aed3b"></a><!-- doxytag: member="apr_pools.h::apr_pool_create" ref="ga918adf3026c894efeae254a0446aed3b" args="(apr_pool_t **newpool, apr_pool_t *parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_pool_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> **&nbsp;</td>
          <td class="paramname"> <em>newpool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new pool. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newpool</em>&nbsp;</td><td>The pool we have just created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>The parent pool. If this is NULL, the new pool is a root pool. If it is non-NULL, the new pool will inherit all of its parent pool's attributes, except the apr_pool_t will be a sub-pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad3675378924bc9d98e46258c049f1761"></a><!-- doxytag: member="apr_pools.h::apr_pool_create_core" ref="gad3675378924bc9d98e46258c049f1761" args="(apr_pool_t **newpool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_pool_create_core </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> **&nbsp;</td>
          <td class="paramname"> <em>newpool</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new pool. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newpool</em>&nbsp;</td><td>The pool we have just created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga20e514c83555398acddc30c4dfa0c540"></a><!-- doxytag: member="apr_pools.h::apr_pool_create_core_ex" ref="ga20e514c83555398acddc30c4dfa0c540" args="(apr_pool_t **newpool, apr_abortfunc_t abort_fn, apr_allocator_t *allocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_pool_create_core_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> **&nbsp;</td>
          <td class="paramname"> <em>newpool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#ga0a1fe549a7c45b864c003ddf12115365">apr_abortfunc_t</a>&nbsp;</td>
          <td class="paramname"> <em>abort_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__allocator.html#ga1ceabfd30fcfc455e47d052d2a24244b">apr_allocator_t</a> *&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new pool. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000033">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__apr__pools.html#gaae7212db77bb57f86419cd594f73a92f">apr_pool_create_unmanaged_ex</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa1c5bfc44188884bb439670f81448c20"></a><!-- doxytag: member="apr_pools.h::apr_pool_create_core_ex_debug" ref="gaa1c5bfc44188884bb439670f81448c20" args="(apr_pool_t **newpool, apr_abortfunc_t abort_fn, apr_allocator_t *allocator, const char *file_line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_pool_create_core_ex_debug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> **&nbsp;</td>
          <td class="paramname"> <em>newpool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#ga0a1fe549a7c45b864c003ddf12115365">apr_abortfunc_t</a>&nbsp;</td>
          <td class="paramname"> <em>abort_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__allocator.html#ga1ceabfd30fcfc455e47d052d2a24244b">apr_allocator_t</a> *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file_line</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Debug version of apr_pool_create_core_ex. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000034">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__apr__pools.html#gae220e572b14355f1aa7b21c8fb022524">apr_pool_create_unmanaged_ex_debug</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gab274bd29e4e4d4944b4618403148074f"></a><!-- doxytag: member="apr_pools.h::apr_pool_create_ex" ref="gab274bd29e4e4d4944b4618403148074f" args="(apr_pool_t **newpool, apr_pool_t *parent, apr_abortfunc_t abort_fn, apr_allocator_t *allocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_pool_create_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> **&nbsp;</td>
          <td class="paramname"> <em>newpool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#ga0a1fe549a7c45b864c003ddf12115365">apr_abortfunc_t</a>&nbsp;</td>
          <td class="paramname"> <em>abort_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__allocator.html#ga1ceabfd30fcfc455e47d052d2a24244b">apr_allocator_t</a> *&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new pool. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newpool</em>&nbsp;</td><td>The pool we have just created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>The parent pool. If this is NULL, the new pool is a root pool. If it is non-NULL, the new pool will inherit all of its parent pool's attributes, except the apr_pool_t will be a sub-pool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>abort_fn</em>&nbsp;</td><td>A function to use if the pool cannot allocate more memory. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>allocator</em>&nbsp;</td><td>The allocator to use with the new pool. If NULL the allocator of the parent pool will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacbea97ae5c0c861f6b7c147d46ac1d0c"></a><!-- doxytag: member="apr_pools.h::apr_pool_create_ex_debug" ref="gacbea97ae5c0c861f6b7c147d46ac1d0c" args="(apr_pool_t **newpool, apr_pool_t *parent, apr_abortfunc_t abort_fn, apr_allocator_t *allocator, const char *file_line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_pool_create_ex_debug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> **&nbsp;</td>
          <td class="paramname"> <em>newpool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#ga0a1fe549a7c45b864c003ddf12115365">apr_abortfunc_t</a>&nbsp;</td>
          <td class="paramname"> <em>abort_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__allocator.html#ga1ceabfd30fcfc455e47d052d2a24244b">apr_allocator_t</a> *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file_line</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Debug version of apr_pool_create_ex. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newpool</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__apr__pools.html#ga918adf3026c894efeae254a0446aed3b">apr_pool_create</a>. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__apr__pools.html#ga918adf3026c894efeae254a0446aed3b">apr_pool_create</a>. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>abort_fn</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__apr__pools.html#ga918adf3026c894efeae254a0446aed3b">apr_pool_create</a>. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>allocator</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__apr__pools.html#ga918adf3026c894efeae254a0446aed3b">apr_pool_create</a>. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>file_line</em>&nbsp;</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Only available when APR_POOL_DEBUG is defined. Call this directly if you have you apr_pool_create_ex calls in a wrapper function and wish to override the file_line argument to reflect the caller of your wrapper function. If you do not have apr_pool_create_ex in a wrapper, trust the macro and don't call apr_pool_create_ex_debug directly. </dd></dl>

</div>
</div>
<a class="anchor" id="gaae7212db77bb57f86419cd594f73a92f"></a><!-- doxytag: member="apr_pools.h::apr_pool_create_unmanaged_ex" ref="gaae7212db77bb57f86419cd594f73a92f" args="(apr_pool_t **newpool, apr_abortfunc_t abort_fn, apr_allocator_t *allocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_pool_create_unmanaged_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> **&nbsp;</td>
          <td class="paramname"> <em>newpool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#ga0a1fe549a7c45b864c003ddf12115365">apr_abortfunc_t</a>&nbsp;</td>
          <td class="paramname"> <em>abort_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__allocator.html#ga1ceabfd30fcfc455e47d052d2a24244b">apr_allocator_t</a> *&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new unmanaged pool. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newpool</em>&nbsp;</td><td>The pool we have just created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>abort_fn</em>&nbsp;</td><td>A function to use if the pool cannot allocate more memory. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>allocator</em>&nbsp;</td><td>The allocator to use with the new pool. If NULL a new allocator will be crated with newpool as owner. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>An unmanaged pool is a special pool without a parent; it will NOT be destroyed upon apr_terminate. It must be explicitly destroyed by calling apr_pool_destroy, to prevent memory leaks. Use of this function is discouraged, think twice about whether you really really need it. </dd></dl>

</div>
</div>
<a class="anchor" id="gae220e572b14355f1aa7b21c8fb022524"></a><!-- doxytag: member="apr_pools.h::apr_pool_create_unmanaged_ex_debug" ref="gae220e572b14355f1aa7b21c8fb022524" args="(apr_pool_t **newpool, apr_abortfunc_t abort_fn, apr_allocator_t *allocator, const char *file_line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_pool_create_unmanaged_ex_debug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> **&nbsp;</td>
          <td class="paramname"> <em>newpool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#ga0a1fe549a7c45b864c003ddf12115365">apr_abortfunc_t</a>&nbsp;</td>
          <td class="paramname"> <em>abort_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__allocator.html#ga1ceabfd30fcfc455e47d052d2a24244b">apr_allocator_t</a> *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file_line</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Debug version of apr_pool_create_unmanaged_ex. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newpool</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>apr_pool_create_unmanaged. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>abort_fn</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>apr_pool_create_unmanaged. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>allocator</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>apr_pool_create_unmanaged. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>file_line</em>&nbsp;</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Only available when APR_POOL_DEBUG is defined. Call this directly if you have you apr_pool_create_unmanaged_ex calls in a wrapper function and wish to override the file_line argument to reflect the caller of your wrapper function. If you do not have apr_pool_create_core_ex in a wrapper, trust the macro and don't call apr_pool_create_core_ex_debug directly. </dd></dl>

</div>
</div>
<a class="anchor" id="ga54759954d2cba7cb649ab5680a33f9e3"></a><!-- doxytag: member="apr_pools.h::apr_pool_destroy" ref="ga54759954d2cba7cb649ab5680a33f9e3" args="(apr_pool_t *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_pool_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the pool. This takes similar action as <a class="el" href="group__apr__pools.html#gafa8a998cd660e82b62aecec09e239d0d">apr_pool_clear()</a> and then frees all the memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The pool to destroy </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This will actually free the memory </dd></dl>

</div>
</div>
<a class="anchor" id="ga7efe64dfcce883d7fad9df813d9259fc"></a><!-- doxytag: member="apr_pools.h::apr_pool_destroy_debug" ref="ga7efe64dfcce883d7fad9df813d9259fc" args="(apr_pool_t *p, const char *file_line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_pool_destroy_debug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file_line</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Debug version of apr_pool_destroy. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>See: apr_pool_destroy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>file_line</em>&nbsp;</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Only available when APR_POOL_DEBUG is defined. Call this directly if you have you apr_pool_destroy calls in a wrapper function and wish to override the file_line argument to reflect the caller of your wrapper function. If you do not have apr_pool_destroy in a wrapper, trust the macro and don't call apr_pool_destroy_debug directly. </dd></dl>

</div>
</div>
<a class="anchor" id="gad64a6a29515621bc13f8a8da50366d67"></a><!-- doxytag: member="apr_pools.h::apr_pool_initialize" ref="gad64a6a29515621bc13f8a8da50366d67" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_pool_initialize </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Setup all of the internal structures required to use pools </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Programs do NOT need to call this directly. APR will call this automatically from apr_initialize. </dd></dl>

</div>
</div>
<a class="anchor" id="ga05d299f778659d1e0806140d8a7fea79"></a><!-- doxytag: member="apr_pools.h::apr_pool_is_ancestor" ref="ga05d299f778659d1e0806140d8a7fea79" args="(apr_pool_t *a, apr_pool_t *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apr_pool_is_ancestor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determine if pool a is an ancestor of pool b. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>The pool to search </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The pool to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if a is an ancestor of b, NULL is considered an ancestor of all pools. </dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>if compiled with APR_POOL_DEBUG, this function will also return true if A is a pool which has been guaranteed by the caller (using apr_pool_join) to have a lifetime at least as long as some ancestor of pool B. </dd></dl>

</div>
</div>
<a class="anchor" id="ga94db31f40609b15b592ff47f989ca9ec"></a><!-- doxytag: member="apr_pools.h::apr_pool_parent_get" ref="ga94db31f40609b15b592ff47f989ca9ec" args="(apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a>* apr_pool_parent_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the parent pool of the specified pool. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>The pool for retrieving the parent pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The parent of the given pool. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeaa872f7999740a60803e95429890518"></a><!-- doxytag: member="apr_pools.h::apr_pool_tag" ref="gaeaa872f7999740a60803e95429890518" args="(apr_pool_t *pool, const char *tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_pool_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>tag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tag a pool (give it a name) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>The pool to tag </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>The tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3728aacec227318cef973b8a33f3b430"></a><!-- doxytag: member="apr_pools.h::apr_pool_terminate" ref="ga3728aacec227318cef973b8a33f3b430" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_pool_terminate </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tear down all of the internal structures required to use pools </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Programs do NOT need to call this directly. APR will call this automatically from apr_terminate. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf930f1fad2cf92a2432c0814c8a0b86f"></a><!-- doxytag: member="apr_pools.h::apr_pool_userdata_get" ref="gaf930f1fad2cf92a2432c0814c8a0b86f" args="(void **data, const char *key, apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_pool_userdata_get </td>
          <td>(</td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the data associated with the current pool. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The user data associated with the pool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key for the data to retrieve </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>The current pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga78d1aa2d9fa842d83eaffccb0f0c0c5c"></a><!-- doxytag: member="apr_pools.h::apr_pool_userdata_set" ref="ga78d1aa2d9fa842d83eaffccb0f0c0c5c" args="(const void *data, const char *key, apr_status_t(*cleanup)(void *), apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_pool_userdata_set </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>cleanup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the data associated with the current pool </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The user data associated with the pool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key to use for association </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cleanup</em>&nbsp;</td><td>The cleanup program to use to cleanup the data (NULL if none) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>The current pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The data to be attached to the pool should have a life span at least as long as the pool it is being attached to.</dd></dl>
<p>Users of APR must take EXTREME care when choosing a key to use for their data. It is possible to accidentally overwrite data by choosing a key that another part of the program is using. Therefore it is advised that steps are taken to ensure that unique keys are used for all of the userdata objects in a particular pool (the same key in two different pools or a pool and one of its subpools is okay) at all times. Careful namespace prefixing of key names is a typical way to help ensure this uniqueness. </p>

</div>
</div>
<a class="anchor" id="ga435644c493dc5b10d80c4b99b8cd4589"></a><!-- doxytag: member="apr_pools.h::apr_pool_userdata_setn" ref="ga435644c493dc5b10d80c4b99b8cd4589" args="(const void *data, const char *key, apr_status_t(*cleanup)(void *), apr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_pool_userdata_setn </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>cleanup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the data associated with the current pool </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>The user data associated with the pool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key to use for association </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cleanup</em>&nbsp;</td><td>The cleanup program to use to cleanup the data (NULL if none) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>The current pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>same as <a class="el" href="group__apr__pools.html#ga78d1aa2d9fa842d83eaffccb0f0c0c5c">apr_pool_userdata_set()</a>, except that this version doesn't make a copy of the key (this function is useful, for example, when the key is a string literal) </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This should NOT be used if the key could change addresses by any means between the <a class="el" href="group__apr__pools.html#ga435644c493dc5b10d80c4b99b8cd4589">apr_pool_userdata_setn()</a> call and a subsequent <a class="el" href="group__apr__pools.html#gaf930f1fad2cf92a2432c0814c8a0b86f">apr_pool_userdata_get()</a> on that key, such as if a static string is used as a userdata key in a DSO and the DSO could be unloaded and reloaded between the _setn() and the _get(). You MUST use <a class="el" href="group__apr__pools.html#ga78d1aa2d9fa842d83eaffccb0f0c0c5c">apr_pool_userdata_set()</a> in such cases. </dd>
<dd>
More generally, the key and the data to be attached to the pool should have a life span at least as long as the pool itself. </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Mon May 23 21:31:32 2011 for Apache Portable Runtime by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
