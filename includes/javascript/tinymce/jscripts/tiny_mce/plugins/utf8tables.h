<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Apache Portable Runtime: Table and Array Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Table and Array Functions<br/>
<small>
[<a class="el" href="group___a_p_r.html">Apache Portability Runtime library</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapr__array__header__t.html">apr_array_header_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapr__table__entry__t.html">apr_table_entry_t</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga84066caaa4c7632671af18c229809fc4">APR_ARRAY_IDX</a>(ary, i, type)&nbsp;&nbsp;&nbsp;(((type *)(ary)-&gt;elts)[i])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga1833b0f940ec03d0b95926812152e1ca">APR_ARRAY_PUSH</a>(ary, type)&nbsp;&nbsp;&nbsp;(*((type *)apr_array_push(ary)))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga867455bb7008872e03b08c0742f9698c">APR_OVERLAP_TABLES_SET</a>&nbsp;&nbsp;&nbsp;(0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga553eea6eb6fea4bafaf4cbd7acafdf5f">APR_OVERLAP_TABLES_MERGE</a>&nbsp;&nbsp;&nbsp;(1)</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga63e76617a1cd3828bbaefcbf93928ec2">apr_array_header_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structapr__table__entry__t.html">apr_table_entry_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#gac7e0151b714e58b75c597dafed75df3f">apr_table_entry_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga0a59d6b321ade650c7cfa31d7fa93dcc">apr_table_do_callback_fn_t</a> )(void *rec, const char *key, const char *value)</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#gaea3005541cce67481f48ab201b5c0cf3">apr_table_elts</a> (const <a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga198e52683a86ecf8df9642990c220ff7">apr_is_empty_table</a> (const <a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#gacae19f5b2182d5813f4ef3050f82ff29">apr_is_empty_array</a> (const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *a)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga8f4308b5a1636ec06544113a9c283304">apr_array_make</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, int nelts, int elt_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#gac08267b32905197dd02ffff3314d9603">apr_array_push</a> (<a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *arr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#gad1ab3e0ca2de25a7ff2fbed393380972">apr_array_pop</a> (<a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *arr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga6a6436840256ed8a47b5d6be4ea2ae03">apr_array_clear</a> (<a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *arr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga532e0f0e4d1e2b7243ebdb7eb1f783c7">apr_array_cat</a> (<a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *dst, const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga327e2d5e29fa49d5a2a31295a6932950">apr_array_copy</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *arr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga6203e9f731bf43e7373857c38d04397d">apr_array_copy_hdr</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *arr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga893cade58c5fabecb593cb4ffac7e9be">apr_array_append</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *first, const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *second)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga6232817e4a32ee5619c99fe55e145c7a">apr_array_pstrcat</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *arr, const char sep)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga7b0a16a1388c68e66bff32190cf092f6">apr_table_make</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, int nelts)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#gae69f2b0b593bcdbf4c678a0f3dfde5f3">apr_table_copy</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, const <a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga7e8bc16b272840302545ed4a6a082a6e">apr_table_clone</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, const <a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga03f03de545f9a18e25420f261938ffea">apr_table_clear</a> (<a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga4db13e3915c6b9a3142b175d4c15d915">apr_table_get</a> (const <a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *t, const char *key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#gaf101d92c2f6343cdf4ec062ff416f244">apr_table_set</a> (<a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *t, const char *key, const char *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga1fe7bb25d4027bb79d3c2bb41d8d8b75">apr_table_setn</a> (<a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *t, const char *key, const char *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#gab0df7a237feb4cd9beed201f4e236127">apr_table_unset</a> (<a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *t, const char *key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#gad5d10eca30b76fb44d999b4dfda8d632">apr_table_merge</a> (<a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *t, const char *key, const char *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga1d50805448114c476cfcd00d5ee3e3a8">apr_table_mergen</a> (<a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *t, const char *key, const char *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#gab2ea874754a0fbf139b7316c1f837f12">apr_table_add</a> (<a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *t, const char *key, const char *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#gaff9fdbd8f499f0dfb07123230e19ea54">apr_table_addn</a> (<a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *t, const char *key, const char *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga783b5c439d46c109bb45e7bc1a6d7ef2">apr_table_overlay</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *p, const <a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *overlay, const <a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *base)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga5917e542ae910961ee48b0ec2d09a879">apr_table_do</a> (<a class="el" href="group__apr__tables.html#ga0a59d6b321ade650c7cfa31d7fa93dcc">apr_table_do_callback_fn_t</a> *comp, void *rec, const <a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *t,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga753c5247c9cd7f90c8958b64d9b6aeae">apr_table_vdo</a> (<a class="el" href="group__apr__tables.html#ga0a59d6b321ade650c7cfa31d7fa93dcc">apr_table_do_callback_fn_t</a> *comp, void *rec, const <a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *t, va_list vp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga603ebc9b97703b855f8ad77640165372">apr_table_overlap</a> (<a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *a, const <a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *b, unsigned flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga7f2a652a0cdaf8c20588823c97a3007f">apr_table_compress</a> (<a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *t, unsigned flags)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Tables are used to store entirely opaque structures for applications, while Arrays are usually used to deal with string lists. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga84066caaa4c7632671af18c229809fc4"></a><!-- doxytag: member="apr_tables.h::APR_ARRAY_IDX" ref="ga84066caaa4c7632671af18c229809fc4" args="(ary, i, type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_ARRAY_IDX</td>
          <td>(</td>
          <td class="paramtype">ary, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(((type *)(ary)-&gt;elts)[i])</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A helper macro for accessing a member of an APR array.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ary</em>&nbsp;</td><td>the array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>the index into the array to return </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>the type of the objects stored in the array</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the item at index i </dd></dl>

</div>
</div>
<a class="anchor" id="ga1833b0f940ec03d0b95926812152e1ca"></a><!-- doxytag: member="apr_tables.h::APR_ARRAY_PUSH" ref="ga1833b0f940ec03d0b95926812152e1ca" args="(ary, type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_ARRAY_PUSH</td>
          <td>(</td>
          <td class="paramtype">ary, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(*((type *)apr_array_push(ary)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A helper macro for pushing elements into an APR array.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ary</em>&nbsp;</td><td>the array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>the type of the objects stored in the array</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the location where the new object should be placed </dd></dl>

</div>
</div>
<a class="anchor" id="ga553eea6eb6fea4bafaf4cbd7acafdf5f"></a><!-- doxytag: member="apr_tables.h::APR_OVERLAP_TABLES_MERGE" ref="ga553eea6eb6fea4bafaf4cbd7acafdf5f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_OVERLAP_TABLES_MERGE&nbsp;&nbsp;&nbsp;(1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>flag for overlap to use apr_table_mergen </p>

</div>
</div>
<a class="anchor" id="ga867455bb7008872e03b08c0742f9698c"></a><!-- doxytag: member="apr_tables.h::APR_OVERLAP_TABLES_SET" ref="ga867455bb7008872e03b08c0742f9698c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_OVERLAP_TABLES_SET&nbsp;&nbsp;&nbsp;(0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>flag for overlap to use apr_table_setn </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga63e76617a1cd3828bbaefcbf93928ec2"></a><!-- doxytag: member="apr_tables.h::apr_array_header_t" ref="ga63e76617a1cd3828bbaefcbf93928ec2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0a59d6b321ade650c7cfa31d7fa93dcc"></a><!-- doxytag: member="apr_tables.h::apr_table_do_callback_fn_t" ref="ga0a59d6b321ade650c7cfa31d7fa93dcc" args=")(void *rec, const char *key, const char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int( <a class="el" href="group__apr__tables.html#ga0a59d6b321ade650c7cfa31d7fa93dcc">apr_table_do_callback_fn_t</a>)(void *rec, const char *key, const char *value)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Declaration prototype for the iterator callback function of <a class="el" href="group__apr__tables.html#ga5917e542ae910961ee48b0ec2d09a879">apr_table_do()</a> and <a class="el" href="group__apr__tables.html#ga753c5247c9cd7f90c8958b64d9b6aeae">apr_table_vdo()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rec</em>&nbsp;</td><td>The data passed as the first argument to apr_table_[v]do() </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key from this iteration of the table </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value from this iteration of the table </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Iteration continues while this callback function returns non-zero. To export the callback function for apr_table_[v]do() it must be declared in the _NONSTD convention. </dd></dl>

</div>
</div>
<a class="anchor" id="gac7e0151b714e58b75c597dafed75df3f"></a><!-- doxytag: member="apr_tables.h::apr_table_entry_t" ref="gac7e0151b714e58b75c597dafed75df3f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapr__table__entry__t.html">apr_table_entry_t</a> <a class="el" href="structapr__table__entry__t.html">apr_table_entry_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The (opaque) structure for string-content tables. </p>

</div>
</div>
<a class="anchor" id="gad7ea82d6608a4a633fc3775694ab71e4"></a><!-- doxytag: member="apr_tables.h::apr_table_t" ref="gad7ea82d6608a4a633fc3775694ab71e4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> <a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>the table abstract data type </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga893cade58c5fabecb593cb4ffac7e9be"></a><!-- doxytag: member="apr_tables.h::apr_array_append" ref="ga893cade58c5fabecb593cb4ffac7e9be" args="(apr_pool_t *p, const apr_array_header_t *first, const apr_array_header_t *second)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__array__header__t.html">apr_array_header_t</a>* apr_array_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&nbsp;</td>
          <td class="paramname"> <em>second</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append one array to the end of another, creating a new array in the process. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The pool to allocate the new array out of </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The array to put first in the new array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>second</em>&nbsp;</td><td>The array to put second in the new array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new array containing the data from the two arrays passed in. </dd></dl>

</div>
</div>
<a class="anchor" id="ga532e0f0e4d1e2b7243ebdb7eb1f783c7"></a><!-- doxytag: member="apr_tables.h::apr_array_cat" ref="ga532e0f0e4d1e2b7243ebdb7eb1f783c7" args="(apr_array_header_t *dst, const apr_array_header_t *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_array_cat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Concatenate two arrays together </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>The destination array, and the one to go first in the combined array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source array to add to the destination array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6a6436840256ed8a47b5d6be4ea2ae03"></a><!-- doxytag: member="apr_tables.h::apr_array_clear" ref="ga6a6436840256ed8a47b5d6be4ea2ae03" args="(apr_array_header_t *arr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_array_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&nbsp;</td>
          <td class="paramname"> <em>arr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all elements from an array. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>arr</em>&nbsp;</td><td>The array to remove all elements from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>As the underlying storage is allocated from a pool, no memory is freed by this operation, but is available for reuse. </dd></dl>

</div>
</div>
<a class="anchor" id="ga327e2d5e29fa49d5a2a31295a6932950"></a><!-- doxytag: member="apr_tables.h::apr_array_copy" ref="ga327e2d5e29fa49d5a2a31295a6932950" args="(apr_pool_t *p, const apr_array_header_t *arr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__array__header__t.html">apr_array_header_t</a>* apr_array_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&nbsp;</td>
          <td class="paramname"> <em>arr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy the entire array </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The pool to allocate the copy of the array out of </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arr</em>&nbsp;</td><td>The array to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An exact copy of the array passed in </dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The alternate apr_array_copy_hdr copies only the header, and arranges for the elements to be copied if (and only if) the code subsequently does a push or arraycat. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6203e9f731bf43e7373857c38d04397d"></a><!-- doxytag: member="apr_tables.h::apr_array_copy_hdr" ref="ga6203e9f731bf43e7373857c38d04397d" args="(apr_pool_t *p, const apr_array_header_t *arr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__array__header__t.html">apr_array_header_t</a>* apr_array_copy_hdr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&nbsp;</td>
          <td class="paramname"> <em>arr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy the headers of the array, and arrange for the elements to be copied if and only if the code subsequently does a push or arraycat. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The pool to allocate the copy of the array out of </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arr</em>&nbsp;</td><td>The array to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An exact copy of the array passed in </dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The alternate apr_array_copy copies the *entire* array. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8f4308b5a1636ec06544113a9c283304"></a><!-- doxytag: member="apr_tables.h::apr_array_make" ref="ga8f4308b5a1636ec06544113a9c283304" args="(apr_pool_t *p, int nelts, int elt_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__array__header__t.html">apr_array_header_t</a>* apr_array_make </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nelts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>elt_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an array </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The pool to allocate the memory out of </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nelts</em>&nbsp;</td><td>the number of elements in the initial array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>elt_size</em>&nbsp;</td><td>The size of each element in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The new array </dd></dl>

</div>
</div>
<a class="anchor" id="gad1ab3e0ca2de25a7ff2fbed393380972"></a><!-- doxytag: member="apr_tables.h::apr_array_pop" ref="gad1ab3e0ca2de25a7ff2fbed393380972" args="(apr_array_header_t *arr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* apr_array_pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&nbsp;</td>
          <td class="paramname"> <em>arr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove an element from an array (as a first-in, last-out stack) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>arr</em>&nbsp;</td><td>The array to remove an element from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Location of the element in the array. </dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>If there are no elements in the array, NULL is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6232817e4a32ee5619c99fe55e145c7a"></a><!-- doxytag: member="apr_tables.h::apr_array_pstrcat" ref="ga6232817e4a32ee5619c99fe55e145c7a" args="(apr_pool_t *p, const apr_array_header_t *arr, const char sep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* apr_array_pstrcat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&nbsp;</td>
          <td class="paramname"> <em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>sep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generates a new string from the apr_pool_t containing the concatenated sequence of substrings referenced as elements within the array. The string will be empty if all substrings are empty or null, or if there are no elements in the array. If sep is non-NUL, it will be inserted between elements as a separator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The pool to allocate the string out of </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arr</em>&nbsp;</td><td>The array to generate the string from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sep</em>&nbsp;</td><td>The separator to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A string containing all of the data in the array. </dd></dl>

</div>
</div>
<a class="anchor" id="gac08267b32905197dd02ffff3314d9603"></a><!-- doxytag: member="apr_tables.h::apr_array_push" ref="gac08267b32905197dd02ffff3314d9603" args="(apr_array_header_t *arr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* apr_array_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&nbsp;</td>
          <td class="paramname"> <em>arr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a new element to an array (as a first-in, last-out stack) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>arr</em>&nbsp;</td><td>The array to add an element to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Location for the new element in the array. </dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>If there are no free spots in the array, then this function will allocate new space for the new element. </dd></dl>

</div>
</div>
<a class="anchor" id="gacae19f5b2182d5813f4ef3050f82ff29"></a><!-- doxytag: member="apr_tables.h::apr_is_empty_array" ref="gacae19f5b2182d5813f4ef3050f82ff29" args="(const apr_array_header_t *a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apr_is_empty_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determine if the array is empty (either NULL or having no elements) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>The array to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if empty, False otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ga198e52683a86ecf8df9642990c220ff7"></a><!-- doxytag: member="apr_tables.h::apr_is_empty_table" ref="ga198e52683a86ecf8df9642990c220ff7" args="(const apr_table_t *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apr_is_empty_table </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determine if the table is empty (either NULL or having no elements) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The table to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if empty, False otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="gab2ea874754a0fbf139b7316c1f837f12"></a><!-- doxytag: member="apr_tables.h::apr_table_add" ref="gab2ea874754a0fbf139b7316c1f837f12" args="(apr_table_t *t, const char *key, const char *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_table_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add data to a table, regardless of whether there is another element with the same key. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The table to add to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The value to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>When adding data, this function makes a copy of both the key and the value. </dd></dl>

</div>
</div>
<a class="anchor" id="gaff9fdbd8f499f0dfb07123230e19ea54"></a><!-- doxytag: member="apr_tables.h::apr_table_addn" ref="gaff9fdbd8f499f0dfb07123230e19ea54" args="(apr_table_t *t, const char *key, const char *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_table_addn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add data to a table, regardless of whether there is another element with the same key. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The table to add to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The value to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>When adding data, this function does not make a copy of the key or the value, so care should be taken to ensure that the values will not change after they have been added.. </dd></dl>

</div>
</div>
<a class="anchor" id="ga03f03de545f9a18e25420f261938ffea"></a><!-- doxytag: member="apr_tables.h::apr_table_clear" ref="ga03f03de545f9a18e25420f261938ffea" args="(apr_table_t *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_table_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete all of the elements from a table </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The table to clear </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7e8bc16b272840302545ed4a6a082a6e"></a><!-- doxytag: member="apr_tables.h::apr_table_clone" ref="ga7e8bc16b272840302545ed4a6a082a6e" args="(apr_pool_t *p, const apr_table_t *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a>* apr_table_clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new table whose contents are deep copied from the given table. A deep copy operation copies all fields, and makes copies of dynamically allocated memory pointed to by the fields. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The pool to allocate the new table out of </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The table to clone </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A deep copy of the table passed in </dd></dl>

</div>
</div>
<a class="anchor" id="ga7f2a652a0cdaf8c20588823c97a3007f"></a><!-- doxytag: member="apr_tables.h::apr_table_compress" ref="ga7f2a652a0cdaf8c20588823c97a3007f" args="(apr_table_t *t, unsigned flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_table_compress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Eliminate redundant entries in a table by either overwriting or merging duplicates</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Table. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>APR_OVERLAP_TABLES_MERGE to merge, or APR_OVERLAP_TABLES_SET to overwrite </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae69f2b0b593bcdbf4c678a0f3dfde5f3"></a><!-- doxytag: member="apr_tables.h::apr_table_copy" ref="gae69f2b0b593bcdbf4c678a0f3dfde5f3" args="(apr_pool_t *p, const apr_table_t *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a>* apr_table_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new table and copy another table into it </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The pool to allocate the new table out of </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The table to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A copy of the table passed in </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The table keys and respective values are not copied </dd></dl>

</div>
</div>
<a class="anchor" id="ga5917e542ae910961ee48b0ec2d09a879"></a><!-- doxytag: member="apr_tables.h::apr_table_do" ref="ga5917e542ae910961ee48b0ec2d09a879" args="(apr_table_do_callback_fn_t *comp, void *rec, const apr_table_t *t,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apr_table_do </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__tables.html#ga0a59d6b321ade650c7cfa31d7fa93dcc">apr_table_do_callback_fn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Iterate over a table running the provided function once for every element in the table. The varargs array must be a list of zero or more (char *) keys followed by a NULL pointer. If zero keys are given, the </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>comp</em>&nbsp;</td><td>function will be invoked for every element in the table. Otherwise, the function is invoked only for those elements matching the keys specified.</td></tr>
  </table>
  </dd>
</dl>
<p>If an invocation of the </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>comp</em>&nbsp;</td><td>function returns zero, iteration will continue using the next specified key, if any.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>comp</em>&nbsp;</td><td>The function to run </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rec</em>&nbsp;</td><td>The data to pass as the first argument to the function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The table to iterate over </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>A varargs array of zero or more (char *) keys followed by NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FALSE if one of the comp() iterations returned zero; TRUE if all iterations returned non-zero </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__apr__tables.html#ga0a59d6b321ade650c7cfa31d7fa93dcc">apr_table_do_callback_fn_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaea3005541cce67481f48ab201b5c0cf3"></a><!-- doxytag: member="apr_tables.h::apr_table_elts" ref="gaea3005541cce67481f48ab201b5c0cf3" args="(const apr_table_t *t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a>* apr_table_elts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the elements from a table </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The table </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An array containing the contents of the table </dd></dl>

</div>
</div>
<a class="anchor" id="ga4db13e3915c6b9a3142b175d4c15d915"></a><!-- doxytag: member="apr_tables.h::apr_table_get" ref="ga4db13e3915c6b9a3142b175d4c15d915" args="(const apr_table_t *t, const char *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* apr_table_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the value associated with a given key from the table. After this call, The data is still in the table </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The table to search for the key </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value associated with the key, or NULL if the key does not exist. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7b0a16a1388c68e66bff32190cf092f6"></a><!-- doxytag: member="apr_tables.h::apr_table_make" ref="ga7b0a16a1388c68e66bff32190cf092f6" args="(apr_pool_t *p, int nelts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a>* apr_table_make </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nelts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make a new table </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The pool to allocate the pool out of </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nelts</em>&nbsp;</td><td>The number of elements in the initial table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The new table. </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This table can only store text data </dd></dl>

</div>
</div>
<a class="anchor" id="gad5d10eca30b76fb44d999b4dfda8d632"></a><!-- doxytag: member="apr_tables.h::apr_table_merge" ref="gad5d10eca30b76fb44d999b4dfda8d632" args="(apr_table_t *t, const char *key, const char *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_table_merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add data to a table by merging the value with data that has already been stored </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The table to search for the data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key to merge data for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The data to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>If the key is not found, then this function acts like apr_table_add </dd></dl>

</div>
</div>
<a class="anchor" id="ga1d50805448114c476cfcd00d5ee3e3a8"></a><!-- doxytag: member="apr_tables.h::apr_table_mergen" ref="ga1d50805448114c476cfcd00d5ee3e3a8" args="(apr_table_t *t, const char *key, const char *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_table_mergen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add data to a table by merging the value with data that has already been stored </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The table to search for the data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key to merge data for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The data to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>If the key is not found, then this function acts like apr_table_addn </dd></dl>

</div>
</div>
<a class="anchor" id="ga603ebc9b97703b855f8ad77640165372"></a><!-- doxytag: member="apr_tables.h::apr_table_overlap" ref="ga603ebc9b97703b855f8ad77640165372" args="(apr_table_t *a, const apr_table_t *b, unsigned flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_table_overlap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For each element in table b, either use setn or mergen to add the data to table a. Which method is used is determined by the flags passed in. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>The table to add the data to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The table to iterate over, adding its data to table a </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>How to add the table to table a. One of: APR_OVERLAP_TABLES_SET Use apr_table_setn APR_OVERLAP_TABLES_MERGE Use apr_table_mergen </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function is highly optimized, and uses less memory and CPU cycles than a function that just loops through table b calling other functions. Conceptually, apr_table_overlap does this:</dd></dl>
<pre>
  <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *barr = apr_table_elts(b);
  <a class="el" href="structapr__table__entry__t.html">apr_table_entry_t</a> *belt = (<a class="el" href="structapr__table__entry__t.html">apr_table_entry_t</a> *)barr-&gt;elts;
  int i;</pre><pre>  for (i = 0; i &lt; barr-&gt;nelts; ++i) {
      if (flags &amp; APR_OVERLAP_TABLES_MERGE) {
          apr_table_mergen(a, belt[i].key, belt[i].val);
      }
      else {
          apr_table_setn(a, belt[i].key, belt[i].val);
      }
  }
 </pre><p>Except that it is more efficient (less space and cpu-time) especially when b has many elements.</p>
<p>Notice the assumptions on the keys and values in b -- they must be in an ancestor of a's pool. In practice b and a are usually from the same pool. </p>

</div>
</div>
<a class="anchor" id="ga783b5c439d46c109bb45e7bc1a6d7ef2"></a><!-- doxytag: member="apr_tables.h::apr_table_overlay" ref="ga783b5c439d46c109bb45e7bc1a6d7ef2" args="(apr_pool_t *p, const apr_table_t *overlay, const apr_table_t *base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a>* apr_table_overlay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>overlay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>base</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Merge two tables into one new table </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>The pool to use for the new table </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>overlay</em>&nbsp;</td><td>The first table to put in the new table </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>base</em>&nbsp;</td><td>The table to add at the end of the new table </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new table containing all of the data from the two passed in </dd></dl>

</div>
</div>
<a class="anchor" id="gaf101d92c2f6343cdf4ec062ff416f244"></a><!-- doxytag: member="apr_tables.h::apr_table_set" ref="gaf101d92c2f6343cdf4ec062ff416f244" args="(apr_table_t *t, const char *key, const char *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_table_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a key/value pair to a table, if another element already exists with the same key, this will over-write the old data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The table to add the data to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key fo use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The value to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>When adding data, this function makes a copy of both the key and the value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1fe7bb25d4027bb79d3c2bb41d8d8b75"></a><!-- doxytag: member="apr_tables.h::apr_table_setn" ref="ga1fe7bb25d4027bb79d3c2bb41d8d8b75" args="(apr_table_t *t, const char *key, const char *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_table_setn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a key/value pair to a table, if another element already exists with the same key, this will over-write the old data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The table to add the data to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The value to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>When adding data, this function does not make a copy of the key or the value, so care should be taken to ensure that the values will not change after they have been added.. </dd></dl>

</div>
</div>
<a class="anchor" id="gab0df7a237feb4cd9beed201f4e236127"></a><!-- doxytag: member="apr_tables.h::apr_table_unset" ref="gab0df7a237feb4cd9beed201f4e236127" args="(apr_table_t *t, const char *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_table_unset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove data from the table </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The table to remove data from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key of the data being removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga753c5247c9cd7f90c8958b64d9b6aeae"></a><!-- doxytag: member="apr_tables.h::apr_table_vdo" ref="ga753c5247c9cd7f90c8958b64d9b6aeae" args="(apr_table_do_callback_fn_t *comp, void *rec, const apr_table_t *t, va_list vp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apr_table_vdo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__tables.html#ga0a59d6b321ade650c7cfa31d7fa93dcc">apr_table_do_callback_fn_t</a> *&nbsp;</td>
          <td class="paramname"> <em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a> *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&nbsp;</td>
          <td class="paramname"> <em>vp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Iterate over a table running the provided function once for every element in the table. The </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vp</em>&nbsp;</td><td>varargs paramater must be a list of zero or more (char *) keys followed by a NULL pointer. If zero keys are given, the </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>comp</em>&nbsp;</td><td>function will be invoked for every element in the table. Otherwise, the function is invoked only for those elements matching the keys specified.</td></tr>
  </table>
  </dd>
</dl>
<p>If an invocation of the </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>comp</em>&nbsp;</td><td>function returns zero, iteration will continue using the next specified key, if any.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>comp</em>&nbsp;</td><td>The function to run </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rec</em>&nbsp;</td><td>The data to pass as the first argument to the function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The table to iterate over </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vp</em>&nbsp;</td><td>List of zero or more (char *) keys followed by NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FALSE if one of the comp() iterations returned zero; TRUE if all iterations returned non-zero </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__apr__tables.html#ga0a59d6b321ade650c7cfa31d7fa93dcc">apr_table_do_callback_fn_t</a> </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Mon May 23 21:31:33 2011 for Apache Portable Runtime by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
